

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Determine the 2D Basis of a Plane &mdash; byxtal 0.post59+g6f320a0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Modules" href="../Modules.html" />
    <link rel="prev" title="Computing the bicrystallographic aspects of Misorientations (FCC lattice)" href="enumerate_byxtal_hcp.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> byxtal
          

          
          </a>

          
            
            
              <div class="version">
                0.post59+g6f320a0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release-history.html">Release History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Conventions-Notations.html">Conventions and Notations used in <strong>byxtal</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="enumerate_byxtal_fcc.html">Computing the bicrystallographic aspects of Misorientations (FCC lattice)</a></li>
<li class="toctree-l2"><a class="reference internal" href="enumerate_byxtal_hcp.html">Computing the bicrystallographic aspects of Misorientations (FCC lattice)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Determine the 2D Basis of a Plane</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Miller-Indices-and-Conventions:">Miller Indices and Conventions:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Problem-Definition:">Problem Definition:</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Finding-Miller-Indices:">Finding Miller Indices:</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Finding-the-Planar-Basis:">Finding the Planar Basis:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">Modules</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">byxtal</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Tutorials</a> &raquo;</li>
        
      <li>Determine the 2D Basis of a Plane</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Tutorials/Basis_2D_Plane.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Determine-the-2D-Basis-of-a-Plane">
<h1>Determine the 2D Basis of a Plane<a class="headerlink" href="#Determine-the-2D-Basis-of-a-Plane" title="Permalink to this headline">¶</a></h1>
<p>The first step in simulating interfaces is the determination of the two-dimensional periodicity (i.e. the basis vectors) of the plane. The interfaces are two-dimensional sections of the underlying three-dimensional lattice, and hence, the interface will exhibit the periodicity of the corresponding 2D lattice of the plane. The technique to determine the basis vectors is outlined in the following article:</p>
<p><a class="reference external" href="https://scripts.iucr.org/cgi-bin/paper?rg5087">**An efficient algorithm for computing the primitive bases of a general lattice plane.**</a> Journal of Applied Crystallography Banadaki, A. D., &amp; Patala, S. (2015). , 48(2), 585-588.</p>
<p>In this tutorial, we will discuss the steps involved in determining the basis vectors of the 2D plane using the <strong>byxtal</strong> package. Please follow the installation steps (link needed!!) to acquire the byxtal package and import all the required packages that we need for completing this tutorial.</p>
<div class="section" id="Miller-Indices-and-Conventions:">
<h2>Miller Indices and Conventions:<a class="headerlink" href="#Miller-Indices-and-Conventions:" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Miller Indices are often used to refer to a given crystallographic plane in crystals.</p></li>
<li><p>However, various conventions are commonly used in determining the Miller Indices that can change the indices of the plane. For example, in the FCC lattice, one could either use the cubic unit-cell or the primitive cell to index planes and directions, resulting in completely different indices for the same plane. Therefore, we would like to declare our conventions in defining the Miller Indices to avoid potential confusion.</p></li>
<li><p>By definition, the Miller indices of a plane, denoted by <span class="math notranslate nohighlight">\((h \, k \, l)\)</span>, refer to the indices of the lattice vector perpendicular to the plane expressed in the reciprocal lattice. Therefore, the indices will depend on the reference lattice used (e.g. the cubic unit-cell or the primitive cell).</p></li>
<li><p>In the <strong>byxtal</strong> package, we perform the calculations in the primitve cell. The reason simply is that, in the primitive lattice, all the lattice points are expressed using integers. This helps with some of the algebraic manipulations that are preformed in the package.</p></li>
<li><p><strong>Unless otherwise specified, the indices in byxtal package are in reference to the primitve cell.</strong></p></li>
<li><p>In the present tutorial, we also discuss how to convert the indices from one reference frame to the other (e.g. from the primitive cell to the cubic unit-cell).</p></li>
</ol>
<p>Let’s start with importing the <strong>byxtal</strong> package and other modules that we will use in this tutorial.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">byxtal</span> <span class="k">as</span> <span class="nn">bxt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">zeros</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Problem-Definition:">
<h2>Problem Definition:<a class="headerlink" href="#Problem-Definition:" title="Permalink to this headline">¶</a></h2>
<p>In the tutorial, we will determine the planar basis of a crystallographic plane in the FCC lattice. Consider the plane whose normal vector is along the direction <span class="math notranslate nohighlight">\([2 3 1]\)</span> expressed in the cubic unit-cell reference frame. Since the normal vector to the plane is provided in the orthogonal unit-cell basis, we will first determine the Miller Indices of the plane (using the primitive cell bases).</p>
<div class="section" id="Finding-Miller-Indices:">
<h3>Finding Miller Indices:<a class="headerlink" href="#Finding-Miller-Indices:" title="Permalink to this headline">¶</a></h3>
<p>A vector in the space can be expressed in any basis, of course with varying components. Vector <span class="math notranslate nohighlight">\(\vec{v}\)</span> in basis A can be expressed as:</p>
<div class="math notranslate nohighlight">
\begin{equation}
\vec{v} = \mathcal{B}_A v_A
\end{equation}</div><p>Similarly we can define the plane normal <span class="math notranslate nohighlight">\(\vec{n}\)</span> in any basis. For instance we can define <span class="math notranslate nohighlight">\(\vec{n}\)</span> in unit-cell basis (<span class="math notranslate nohighlight">\(\mathcal{B}_{PO}\)</span>) or in primitive-cell basis <span class="math notranslate nohighlight">\(\mathcal{B}_P\)</span>; we can write:</p>
<div class="math notranslate nohighlight">
\begin{equation}
\vec{n} = \mathcal{B}_{PO} n_{PO} = \mathcal{B}_{P} n_{P}
\end{equation}</div><p>The conversion from one basis to the other can be determined by using the components of the basis vectors of one of the frames (e.g. <span class="math notranslate nohighlight">\(P\)</span>) in the other frame (e.g. <span class="math notranslate nohighlight">\(PO\)</span>):</p>
<div class="math notranslate nohighlight">
\begin{equation}
\mathcal{B}_{P} = \mathcal{B}_{PO} \Lambda_{P}^{PO}
\end{equation}</div><p>where, <span class="math notranslate nohighlight">\(\Lambda_P^{PO}\)</span> is a <span class="math notranslate nohighlight">\(3 \times 3\)</span> matrix with its columns representing the components of basis vectors of <span class="math notranslate nohighlight">\(P\)</span> frame in the <span class="math notranslate nohighlight">\(PO\)</span> basis. For example, for an FCC lattice, <span class="math notranslate nohighlight">\(\Lambda_P^{PO}\)</span> is given below.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">l_p_po</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">]])</span>
<span class="n">l_p_po</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}0 &amp; 0.5 &amp; 0.5\\0.5 &amp; 0 &amp; 0.5\\0.5 &amp; 0.5 &amp; 0\end{matrix}\right]$</div></div>
</div>
<p>We can now determine the components of the vector <span class="math notranslate nohighlight">\(\vec{n}\)</span> in the <span class="math notranslate nohighlight">\(P\)</span> reference frame as follows:</p>
<div class="math notranslate nohighlight">
\begin{align}
\mathcal{B}_{P} n_{P} &amp;= \mathcal{B}_{PO} n_{P0} \\ \nonumber
\mathcal{B}_{PO} \Lambda_{P}^{PO} n_{P} &amp;= \mathcal{B}_{PO} n_{P0} \\ \nonumber
\Lambda_{P}^{PO} n_{P} &amp;= \mathcal{B}_{PO} n_{P0} \\ \nonumber
n_{P} &amp;= \Lambda_{PO}^{P} n_{P0}
\end{align}</div><p>where <span class="math notranslate nohighlight">\(\Lambda_{P}^{PO} = \left( \Lambda_{PO}^{P} \right)^{-1}\)</span>.</p>
<ol class="arabic simple">
<li><p><strong>To determine the Miller indices</strong>, we have to express the components of the normal vector <span class="math notranslate nohighlight">\(\vec{n}\)</span> in the reference frame of the reciprocal lattice (the reciprocal of the primitive cell).</p></li>
<li><p>The basis vectors of the reciprocal of the primitve lattice are denoted using the symbol <span class="math notranslate nohighlight">\(\mathcal{B}^*_{P}\)</span>, and are given in the <span class="math notranslate nohighlight">\(PO\)</span> reference frame as:</p></li>
</ol>
<div class="math notranslate nohighlight">
\begin{equation}
\mathcal{B}^*_{P} = \mathcal{B}_{PO} \Lambda_{P*}^{PO}
\end{equation}</div><ol class="arabic simple" start="3">
<li><p><span class="math notranslate nohighlight">\(\Lambda_{P*}^{PO}\)</span> can be computed using the byxtal package using the function <code class="docutils literal notranslate"><span class="pre">bxt.find_csl_dsc.reciprocal_mat()</span></code>. For the sake of convenience we abbreviate the imported module <code class="docutils literal notranslate"><span class="pre">bxt.find_csl_dsc</span></code> as <code class="docutils literal notranslate"><span class="pre">fcd</span></code>. The code is shown below.</p></li>
</ol>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">byxtal.find_csl_dsc</span> <span class="k">as</span> <span class="nn">fcd</span>
<span class="n">l_rp_po</span> <span class="o">=</span> <span class="n">fcd</span><span class="o">.</span><span class="n">reciprocal_mat</span><span class="p">(</span><span class="n">l_p_po</span><span class="p">)</span>
<span class="n">l_rp_po</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}-1.0 &amp; 1.0 &amp; 1.0\\1.0 &amp; -1.0 &amp; 1.0\\1.0 &amp; 1.0 &amp; -1.0\end{matrix}\right]$</div></div>
</div>
<p>where we use the variable <code class="docutils literal notranslate"><span class="pre">l_rp_po</span></code> to represent <span class="math notranslate nohighlight">\(\Lambda_{P*}^{PO}\)</span>. Now, we can determine the indices of <span class="math notranslate nohighlight">\(\vec{n}\)</span> in the <span class="math notranslate nohighlight">\(P^*\)</span> reference frame, using equation (4) as:</p>
<div class="math notranslate nohighlight">
\begin{equation}
n_{P^*} = \Lambda_{PO}^{P*} n_{P0}
\end{equation}</div><p>Use the following code to determine the components <span class="math notranslate nohighlight">\(n_{P^*}\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">l_po_rp</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_rp_po</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
<span class="n">n_po</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">n_rp</span> <span class="o">=</span> <span class="n">l_po_rp</span><span class="o">*</span><span class="n">n_po</span>
<span class="n">n_rp</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}2.0\\1.5\\2.5\end{matrix}\right]$</div></div>
</div>
<p>Remember, that the Miller Indices ought to be integers (without common factors). We have to find a common scaling factor for all the components such that the result is going to be scalar. We have implemented a function named <code class="docutils literal notranslate"><span class="pre">int_finder</span></code> that performs this task for a variety of input types (e.g. rows and columns of matrices). For irrational numbers int_finder accepts a tolerance and performs the same operation on the closest rational number within the specified tolerance. You can find this
function in the package as: <code class="docutils literal notranslate"><span class="pre">byxtal.integer_manipulations.int_finder()</span></code>. Therefore, we repeat the previous steps and pass the results to the <code class="docutils literal notranslate"><span class="pre">int_finder</span></code> function to obtain the integer Miller indices.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">byxtal.integer_manipulations</span> <span class="k">as</span> <span class="nn">iman</span>
<span class="n">ni_rp</span> <span class="o">=</span> <span class="n">iman</span><span class="o">.</span><span class="n">int_finder</span><span class="p">(</span><span class="n">n_rp</span><span class="p">)</span>
<span class="n">ni_rp</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}4\\3\\5\end{matrix}\right]$</div></div>
</div>
</div>
</div>
<div class="section" id="Finding-the-Planar-Basis:">
<h2>Finding the Planar Basis:<a class="headerlink" href="#Finding-the-Planar-Basis:" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>From the previous section, we found the Miller Indices of an FCC plane with the normal along <span class="math notranslate nohighlight">\(n_{PO} = [2 3 1]\)</span> to be <span class="math notranslate nohighlight">\((4 3 5)\)</span>.</p></li>
<li><p>Now all we have to do is to pass the obtained indices to <code class="docutils literal notranslate"><span class="pre">bp_basis</span></code>, which is a function that gets the Miller Indices (expressed using the primitive cell) as the input and returns a <span class="math notranslate nohighlight">\(3 \times 2\)</span> matrix, where the columns represent the components of the basis vectors in the primitive <span class="math notranslate nohighlight">\((P)\)</span> reference frame.</p></li>
<li><p>Also the obtained vectors are in the <a class="reference external" href="https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm">reduced form</a>. You can find the bp_basis function in the following path: <code class="docutils literal notranslate"><span class="pre">byxtal.bp_basis.bp_basis()</span></code>. To find the basis vector of a plane with the Miller Indices of <span class="math notranslate nohighlight">\((4 3 5)\)</span> use the following syntax:</p></li>
</ol>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">byxtal.bp_basis</span> <span class="k">as</span> <span class="nn">bpb</span>
<span class="n">l_2D_p</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">bpb</span><span class="o">.</span><span class="n">bp_basis</span><span class="p">(</span><span class="n">ni_rp</span><span class="p">))</span>
<span class="n">l_2D_p</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}2.0 &amp; 1.0\\-1.0 &amp; 2.0\\-1.0 &amp; -2.0\end{matrix}\right]$</div></div>
</div>
<p>To express the obtained basis in the orthogonal basis (i.e. supercell f.c.c) one needs to perform the following conversion of bases:</p>
<div class="math notranslate nohighlight">
\begin{equation}
\Lambda_{2D}^{PO} = \Lambda_{P}^{PO} \times \Lambda_{2D}^{P}
\end{equation}</div><div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">l_2D_po</span> <span class="o">=</span> <span class="n">l_p_po</span><span class="o">*</span><span class="n">l_2D_p</span>
<span class="n">l_2D_po</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="math notranslate nohighlight">
$\displaystyle \left[\begin{matrix}-1.0 &amp; 0\\0.5 &amp; -0.5\\0.5 &amp; 1.5\end{matrix}\right]$</div></div>
</div>
</div>
<div class="section" id="Summary">
<h2>Summary<a class="headerlink" href="#Summary" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>At the interface of a bicrystal, the <span class="math notranslate nohighlight">\(\Lambda_{2D}^{PO}\)</span> provides a basis for the interface.</p></li>
<li><p>If the two crystals are related to each other by a <span class="math notranslate nohighlight">\(\Sigma\)</span>-rotation, the obtained <span class="math notranslate nohighlight">\(\Lambda_{2D}^{po}\)</span> is the two-dimensional basis for the two-dimensional coincidence site lattice at the interface. Therefore, the bicrystal conserves its periodicity in the obtained 2D-basis.</p></li>
<li><p>In other words the obtained basis is in fact the basis for the unit cell of the bicrystal and since it is in the reduced form, it is going to have the least skewness, hence ideal for constructing a periodic simulation box.</p></li>
</ol>
<p>The above process is frquently repeated for simulation of grain boundaries. Therefore, we have developed a set of functions that make the conversion of indices more convenient and will accept various conventions for the Miller Indices. Please refer to the grain boundary 2D-CSL tutorial for how to use these functions.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="../Modules.html" class="btn btn-neutral float-right" title="Modules" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="enumerate_byxtal_hcp.html" class="btn btn-neutral float-left" title="Computing the bicrystallographic aspects of Misorientations (FCC lattice)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Leila Khalili.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>